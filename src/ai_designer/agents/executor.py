"""
FreeCAD Execution Agent - Executes generated scripts safely.

This module provides a wrapper for executing FreeCAD scripts generated by
the GeneratorAgent. It can be passed as an execution_callback to the
OrchestratorAgent to enable automated script execution and validation.
"""

from pathlib import Path
from typing import Any, Dict, Optional

from ai_designer.core.logging_config import get_logger
from ai_designer.core.sandbox import ExecutionResult, execute_safe_script

logger = get_logger(__name__)


class FreeCADExecutor:
    """
    Executes FreeCAD scripts safely via sandbox.

    Can be passed as execution_callback to OrchestratorAgent for
    automated script execution during the design workflow.

    Features:
    - Safe execution via sandboxed subprocess
    - Configurable timeout
    - Automatic output saving
    - Comprehensive error handling
    - Object tracking and metadata extraction
    """

    def __init__(
        self,
        timeout: int = 60,
        freecad_path: Optional[str] = None,
        save_outputs: bool = True,
        outputs_dir: str = "outputs",
    ):
        """
        Initialize FreeCAD executor.

        Args:
            timeout: Maximum execution time in seconds (default: 60)
            freecad_path: Path to FreeCAD executable or AppImage (auto-detect if None)
            save_outputs: Whether to save generated models (default: True)
            outputs_dir: Directory for saved outputs (default: "outputs")
        """
        self.timeout = timeout
        self.freecad_path = freecad_path
        self.save_outputs = save_outputs
        self.outputs_dir = Path(outputs_dir)

        # Create outputs directory if it doesn't exist
        if self.save_outputs:
            self.outputs_dir.mkdir(parents=True, exist_ok=True)

        logger.info(
            "Initialized FreeCADExecutor",
            timeout=timeout,
            save_outputs=save_outputs,
            outputs_dir=str(self.outputs_dir),
        )

    async def execute(
        self, scripts: Dict[str, str], document_name: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Execute FreeCAD scripts.

        This method can be passed directly to OrchestratorAgent.execute()
        as the execution_callback parameter.

        Args:
            scripts: Dictionary of {task_id: script_code}
            document_name: Optional FreeCAD document name

        Returns:
            Dictionary with execution results:
            - success: bool - Overall success status
            - executed_count: int - Number of scripts executed
            - failed_count: int - Number of scripts that failed
            - created_objects: List[str] - Names of created objects
            - errors: List[str] - Error messages if any
            - execution_time: float - Total execution time
            - document_path: str - Path to saved document (if save_outputs=True)

        Example:
            >>> executor = FreeCADExecutor(timeout=60, save_outputs=True)
            >>> scripts = {"task_1": "box = Part.makeBox(10, 10, 10)\\nPart.show(box)"}
            >>> result = await executor.execute(scripts)
            >>> print(f"Created {len(result['created_objects'])} objects")
        """
        logger.info("Executing FreeCAD scripts", count=len(scripts))

        results = {
            "success": True,
            "executed_count": 0,
            "failed_count": 0,
            "created_objects": [],
            "errors": [],
            "execution_time": 0.0,
            "document_path": None,
        }

        # Combine all scripts in order
        # TODO: In future, could execute in dependency order from task graph
        combined_script = "\n\n".join(
            f"# Task: {task_id}\n{script}" for task_id, script in scripts.items()
        )

        try:
            # Execute via sandbox
            exec_result: ExecutionResult = execute_safe_script(
                script=combined_script,
                timeout=self.timeout,
                document_name=document_name,
                freecad_path=self.freecad_path,
            )

            if exec_result.success:
                results["success"] = True
                results["executed_count"] = len(scripts)
                results["created_objects"] = exec_result.created_objects
                results["execution_time"] = exec_result.execution_time

                if exec_result.document_path:
                    results["document_path"] = str(exec_result.document_path)

                logger.info(
                    "Scripts executed successfully",
                    objects=len(exec_result.created_objects),
                    time=f"{exec_result.execution_time:.2f}s",
                    document=exec_result.document_path,
                )
            else:
                results["success"] = False
                results["failed_count"] = len(scripts)
                results["errors"].append(exec_result.error or "Unknown error")

                logger.error("Script execution failed", error=exec_result.error)

        except Exception as e:
            results["success"] = False
            results["failed_count"] = len(scripts)
            results["errors"].append(str(e))
            logger.error("Execution exception", error=str(e), exc_info=True)

        return results

    def execute_sync(
        self, scripts: Dict[str, str], document_name: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Synchronous version of execute() for non-async contexts.

        Args:
            scripts: Dictionary of {task_id: script_code}
            document_name: Optional FreeCAD document name

        Returns:
            Same as execute()
        """
        import asyncio

        return asyncio.run(self.execute(scripts, document_name))
