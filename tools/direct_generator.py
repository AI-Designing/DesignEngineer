#!/usr/bin/env python3
"""
Direct Online LLM Component Generator
Generate complex mechanical components directly using an online LLM (Gemini 2.0 Flash / GPT-4o)
"""

import json
import logging
import os
import subprocess
import sys
import time
from datetime import datetime
from pathlib import Path

# Add src to path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), "src"))

from ai_designer.llm.providers.deepseek import DeepSeekMode
from ai_designer.llm.providers.online_codegen import (
    OnlineCodeGenClient,
    OnlineCodeGenConfig,
)

# Keep legacy aliases so any callers that import these names still work
DeepSeekConfig = OnlineCodeGenConfig
DeepSeekR1Client = OnlineCodeGenClient

# Configure logging
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)


def generate_component(requirements: str, mode: DeepSeekMode = DeepSeekMode.REASONING):
    """Generate a single component using the online code-gen client."""

    logger.info("\U0001f680 Generating component via online LLM")
    logger.info(f"\U0001f4cb Requirements: {requirements}")
    logger.info(f"\u2699\ufe0f Mode: {mode.value}")

    # Initialize online client (reads model from env or defaults to gemini-2.0-flash)
    client = OnlineCodeGenClient()
    logger.info(f"\U0001f4e1 Using model: {client.config.model}")

    # Generate component
    start_time = time.time()
    response = client.generate_complex_part(
        requirements=requirements,
        mode=mode,
        context={"timestamp": datetime.now().isoformat()},
        constraints={"output_format": "freecad_python"},
    )

    generation_time = time.time() - start_time

    # Process results
    if response.status == "success":
        logger.info(f"‚úÖ Generation successful!")
        logger.info(f"‚è±Ô∏è Time: {generation_time:.2f}s")
        logger.info(f"üéØ Confidence: {response.confidence_score:.2f}")
        logger.info(f"üß† Reasoning steps: {len(response.reasoning_chain)}")

        # Display reasoning chain
        if response.reasoning_chain:
            logger.info("üîç Reasoning Chain:")
            for i, step in enumerate(
                response.reasoning_chain[:3]
            ):  # Show first 3 steps
                logger.info(f"   {i+1}. {step.description}")

        # Save the generated code
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        output_dir = Path("outputs") / f"direct_generation_{timestamp}"
        output_dir.mkdir(parents=True, exist_ok=True)

        # Save code
        code_file = output_dir / "generated_component.py"
        with open(code_file, "w") as f:
            f.write(f"# Generated by DeepSeek R1 - {datetime.now()}\n")
            f.write(f"# Requirements: {requirements}\n")
            f.write(f"# Confidence: {response.confidence_score:.2f}\n")
            f.write(f"# Generation time: {generation_time:.2f}s\n\n")
            f.write(response.generated_code)

        # Save metadata
        metadata = {
            "requirements": requirements,
            "mode": mode.value,
            "generation_time": generation_time,
            "confidence_score": response.confidence_score,
            "status": response.status,
            "reasoning_steps": len(response.reasoning_chain),
            "complexity_analysis": response.complexity_analysis,
            "optimization_suggestions": response.optimization_suggestions,
        }

        metadata_file = output_dir / "metadata.json"
        with open(metadata_file, "w") as f:
            json.dump(metadata, f, indent=2)

        logger.info(f"üíæ Files saved to: {output_dir}")

        # Display generated code (first 500 chars)
        if response.generated_code:
            code_preview = (
                response.generated_code[:500] + "..."
                if len(response.generated_code) > 500
                else response.generated_code
            )
            logger.info(f"üìù Generated Code Preview:\n{code_preview}")

        return output_dir, response

    else:
        logger.error(f"‚ùå Generation failed: {response.error_message}")
        return None, response


def execute_freecad_component(code_file: Path):
    """Execute the generated FreeCAD code"""

    logger.info(f"üîß Executing FreeCAD component: {code_file.name}")

    # Create enhanced FreeCAD script
    with open(code_file, "r") as f:
        original_code = f.read()

    enhanced_script = f"""#!/usr/bin/env python3
import FreeCAD as App
import Part
import Draft

# Create new document
doc = App.newDocument("DirectGeneration")

print("[FreeCAD] Starting component generation...")

try:
    # Generated code
{_indent_code(original_code)}

    # Fit view and save
    doc.recompute()

    # Save document
    output_path = "{code_file.parent}/generated_model.FCStd"
    doc.saveAs(output_path)
    print(f"[FreeCAD] Model saved to: {{output_path}}")

    # Export to STEP
    step_path = "{code_file.parent}/generated_model.step"
    import Import
    objects = [obj for obj in doc.Objects if hasattr(obj, 'Shape')]
    if objects:
        Import.export(objects, step_path)
        print(f"[FreeCAD] STEP exported to: {{step_path}}")

    print("[FreeCAD] Component generation completed successfully")

except Exception as e:
    print(f"[FreeCAD] Error: {{e}}")
    import traceback
    traceback.print_exc()
"""

    # Write enhanced script
    enhanced_file = code_file.parent / "enhanced_freecad_script.py"
    with open(enhanced_file, "w") as f:
        f.write(enhanced_script)

    # Execute with FreeCAD
    cmd = ["freecad", "--console", "--run-python", str(enhanced_file)]
    logger.info(f"üöÄ Running: {' '.join(cmd)}")

    result = subprocess.run(cmd, capture_output=True, text=True)

    if result.returncode == 0:
        logger.info(f"‚úÖ FreeCAD execution successful")
        return True
    else:
        logger.error(f"‚ùå FreeCAD execution failed (exit code: {result.returncode})")
        return False


def _indent_code(code: str, spaces: int = 4) -> str:
    """Indent code for script embedding"""
    lines = code.split("\\n")
    indented = [" " * spaces + line if line.strip() else line for line in lines]
    return "\\n".join(indented)


def main():
    """Main function"""

    # Define some example components to generate
    components = [
        {
            "name": "Precision Shaft",
            "requirements": "Create a precision shaft with diameter 25mm, length 150mm, with a 8x7mm keyway in the center, and 1mm chamfers on both ends",
            "mode": DeepSeekMode.TECHNICAL,
        },
        {
            "name": "Gear Assembly",
            "requirements": "Design a spur gear with 24 teeth, module 2mm, 20-degree pressure angle, with a central bore of 10mm diameter and keyway",
            "mode": DeepSeekMode.REASONING,
        },
        {
            "name": "Bearing Housing",
            "requirements": "Create a bearing housing for a 6205 ball bearing (25mm ID, 52mm OD, 15mm width) with mounting holes and oil seals",
            "mode": DeepSeekMode.TECHNICAL,
        },
        {
            "name": "Creative Bracket",
            "requirements": "Design an innovative adjustable mounting bracket with multiple mounting points and aesthetic curves",
            "mode": DeepSeekMode.CREATIVE,
        },
        {
            "name": "Complex Assembly",
            "requirements": "Create a complete linear actuator assembly with shaft, housing, bearings, and connection points",
            "mode": DeepSeekMode.REASONING,
        },
    ]

    logger.info("üéØ Direct Component Generation with DeepSeek R1")
    logger.info("=" * 60)

    successful = 0
    failed = 0

    for i, component in enumerate(components, 1):
        logger.info(
            f"\nüî® Generating Component {i}/{len(components)}: {component['name']}"
        )
        logger.info("-" * 40)

        try:
            output_dir, response = generate_component(
                component["requirements"], component["mode"]
            )

            if output_dir:
                successful += 1

                # Execute the generated code
                code_file = output_dir / "generated_component.py"
                if code_file.exists():
                    logger.info("üöÄ Executing generated component...")
                    exec_success = execute_freecad_component(code_file)
                    if exec_success:
                        logger.info("üé® FreeCAD execution completed successfully")
                    else:
                        logger.warning("‚ö†Ô∏è FreeCAD execution had issues")
            else:
                failed += 1

        except Exception as e:
            logger.error(f"‚ùå Error generating {component['name']}: {e}")
            failed += 1

        # Brief pause between generations
        if i < len(components):
            logger.info("‚è≥ Brief pause before next generation...")
            time.sleep(5)

    # Summary
    logger.info(f"\nüèÅ Generation Summary")
    logger.info("=" * 30)
    logger.info(f"‚úÖ Successful: {successful}")
    logger.info(f"‚ùå Failed: {failed}")
    logger.info(f"üìà Success Rate: {(successful/len(components)*100):.1f}%")

    return 0


if __name__ == "__main__":
    sys.exit(main())
